apiVersion: v1
kind: ConfigMap
metadata:
  name: benchmark-config
  namespace: iceberg-benchmark
data:
  spark-defaults.conf: |
    spark.master                     k8s://https://kubernetes.default.svc:443
    spark.kubernetes.container.image iceberg-benchmark:latest
    spark.kubernetes.namespace       iceberg-benchmark
    spark.kubernetes.serviceaccount iceberg-benchmark-sa
    spark.sql.extensions            org.apache.iceberg.spark.extensions.IcebergSparkSessionExtensions
    spark.sql.catalog.spark_catalog  org.apache.iceberg.spark.SparkSessionCatalog
    spark.sql.catalog.spark_catalog.type hive
    spark.sql.catalog.local          org.apache.iceberg.spark.SparkCatalog
    spark.sql.catalog.local.type     hadoop
    spark.sql.catalog.local.warehouse /tmp/iceberg-warehouse
    spark.serializer                 org.apache.spark.serializer.KryoSerializer
    spark.sql.adaptive.enabled       true
    spark.sql.adaptive.coalescePartitions.enabled true
    spark.eventLog.enabled           true
    spark.eventLog.dir               /tmp/spark-events
    spark.history.fs.logDirectory    /tmp/spark-events
    
  log4j.properties: |
    # Root logger
    log4j.rootCategory=INFO, console
    
    # Console appender
    log4j.appender.console=org.apache.log4j.ConsoleAppender
    log4j.appender.console.target=System.err
    log4j.appender.console.layout=org.apache.log4j.PatternLayout
    log4j.appender.console.layout.ConversionPattern=%d{yy/MM/dd HH:mm:ss} %p %c{1}: %m%n
    
    # Reduce verbosity for some loggers
    log4j.logger.org.spark-project.jetty=WARN
    log4j.logger.org.spark-project.jetty.util.component.AbstractLifeCycle=ERROR
    log4j.logger.org.apache.spark.repl.SparkIMain$exprTyper=INFO
    log4j.logger.org.apache.spark.repl.SparkILoop$SparkILoopInterpreter=INFO
    log4j.logger.org.apache.parquet=ERROR
    log4j.logger.parquet=ERROR
    log4j.logger.org.apache.hadoop.hive.metastore.RetryingHMSHandler=FATAL
    log4j.logger.org.apache.hadoop.hive.ql.exec.FunctionRegistry=ERROR
---
apiVersion: v1
kind: ConfigMap  
metadata:
  name: tpcds-queries
  namespace: iceberg-benchmark
data:
  q1.sql: |
    WITH customer_total_return AS (
      SELECT sr_customer_sk AS ctr_customer_sk,
             sr_store_sk AS ctr_store_sk,
             SUM(sr_return_amt) AS ctr_total_return
      FROM store_returns,
           date_dim
      WHERE sr_returned_date_sk = d_date_sk
        AND d_year = 2000
      GROUP BY sr_customer_sk, sr_store_sk
    )
    SELECT c_customer_id
    FROM customer_total_return ctr1,
         store,
         customer
    WHERE ctr1.ctr_total_return > (SELECT AVG(ctr_total_return) * 1.2
                                   FROM customer_total_return ctr2
                                   WHERE ctr1.ctr_store_sk = ctr2.ctr_store_sk)
      AND s_store_sk = ctr1.ctr_store_sk
      AND s_state = 'TN'
      AND ctr1.ctr_customer_sk = c_customer_sk
    ORDER BY c_customer_id
    LIMIT 100;

  q3.sql: |
    SELECT dt.d_year,
           item.i_brand_id AS brand_id,
           item.i_brand AS brand,
           SUM(ss_sales_price) AS sum_agg
    FROM date_dim dt,
         store_sales,
         item
    WHERE dt.d_date_sk = store_sales.ss_sold_date_sk
      AND store_sales.ss_item_sk = item.i_item_sk
      AND item.i_manufact_id = 436
      AND dt.d_moy = 12
    GROUP BY dt.d_year,
             item.i_brand,
             item.i_brand_id
    ORDER BY dt.d_year,
             sum_agg DESC,
             brand_id
    LIMIT 100;

  q6.sql: |
    SELECT a.ca_state AS state,
           COUNT(*) AS cnt
    FROM customer_address a,
         customer c,
         store_sales s,
         date_dim d,
         item i
    WHERE a.ca_address_sk = c.c_current_addr_sk
      AND c.c_customer_sk = s.ss_customer_sk
      AND s.ss_sold_date_sk = d.d_date_sk
      AND s.ss_item_sk = i.i_item_sk
      AND d.d_month_seq = 
           (SELECT DISTINCT d_month_seq
            FROM date_dim
            WHERE d_year = 2000
              AND d_moy = 2)
      AND i.i_current_price > 1.2 * 
          (SELECT AVG(j.i_current_price)
           FROM item j
           WHERE j.i_category = i.i_category)
    GROUP BY a.ca_state
    HAVING COUNT(*) >= 10
    ORDER BY cnt, a.ca_state
    LIMIT 100;
